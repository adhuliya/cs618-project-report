%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This report documents the work done to port the constraint generation plugin from
\verb+GCC 4.7.2+ to \verb+GCC 5.2.0+. The constraint generation plugin extracts the pointer based constraints from the GIMPLE IR during LTO (Link Time Optimization) phase and dumps them in an output file. These constraints are then used for many other pointer analysis based optimizations developed in-house.

The rest of the report documents the general approach followed to port the plugin; then the list of contraints detected by the plugin are listed with test cases; then the  pattern of changes observed from \verb+GCC 4.7.2+ to \verb+GCC 5.2.0+ are listed (although not exhaustive); and at last the future work discusses the work remaining.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach Followed}\label{sec:appoach-followed}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section summarises the approach followed to port the plugin. We believe this might help us to port other (if any) plugins in the future. Some of the methods are specific for this plugin. We tried understanding the code before making changes, but the direct source level changes eventually gave much quicker results. The  basic approachs are enumerated below:

\begin{enumerate}
    \item Compilation was the first problem. So we adopted the incremental apporach where we added source code in logical units, files, functions etc. This helped us tackle small number of issues at a time. The functions were added by following the call hirarchy from the top. This helped us include only those functions that were reachable/used. This helped reduce the size of the code drastically.

    \item How to adapt the source code was another problem. Here we compared the tree-ssa-structalias.c in \verb+GCC 4.7.2+ and \verb+GCC 5.2.0+, and most of the differences were straight forward to understand. This worked because, the plugin was an adaptation of tree-ssa-structalias.c in \verb+GCC 4.7.2+.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{List of Constraints Generated by the Plugin}\label{sec:constraints}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section tries to enumerate all possible constraints. Each test-case and its constraints are listed below.

The programs have been created with some naming conventions of variables to make it easy to understant the type of constraints when reading. \prettyref{table:varname} outlines the names and their associated meaning.

\begin{table}
\begin{center}
    \begin{tabular}{| m{10ex} | m{70ex} |}
    \hline
    \textbf{Name} & \textbf{Meaning} \\
    \hline
    \hline
    i & Read `i' as `integer'. \\
    \hline
    pi & Read `pi' as `pointer-to integer'.\\
    \hline
    ppi & Read `ppi' as `pointer-to pointer-to integer'. Therefore, *ppi would be a pointer-to interger. \\
    \hline
    piA, piB & Read `piA' as  `pointer-to integer A'. Capital letter suffixes like A, B, \ldots{} are used only to make the names distinct. \\
    \hline
    f & Read `f' as `function'.\\
    \hline
    fA, fB & Functions with different names. Capital letter suffixes like A, B, \ldots{} are used to make the names distinct. Read `fA' as `function A'.\\
    \hline
    fp & Read `fp' as `function parameter'. Note that here `p' is used after `f' and hence is no more read as `points-to'.\\
    \hline
    \end{tabular}
    \caption{Testcase variables naming conventions}
    \label{table:varname}
\end{center}
\end{table}

\subsection{Basic Pointer Constraints}
Constraints related to pointer(s) to basic datatypes.
\subsubsection{Single Pointer to Integer} Here the pointer is pointing to an integer. It could point to any other basic datatype, generating similar constraints.

\begin{figure}
\label{fig:test-01}
\lstinputlisting[language=C]{resources/test-01.c}
\caption{test-01.c}
\end{figure}

    \begin{center}
        \begin{longtable}{| m{10ex} | m{75ex} |}

\caption{test-01 constraints\label{table:test-01-constr}} \\
            \hline
            \textbf{Tag} & \textbf{Content} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi = \&i} \\ \hline
            GIMPLE & \texttt{pi\_1 = \&i} \\ \hline
            Constraint & \texttt{LHS: var id 8, ptr\_ arith=0, offset 0(), type 0, name pi\newline RHS: var id 9, ptr\_ arith=0, offset 0(), type 2, name i} \\
            \hline 
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{i = *pi} \\ \hline
            GIMPLE & \texttt{i.0\_2 = *pi\_1} \\ \hline
            Constraint & \texttt{Var id 8, name pi, offset 0} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi = pi + 1} \\ \hline
            GIMPLE & \texttt{pi\_3 = pi\_1 + 4} \\ \hline
            Constraint & \texttt{LHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi,\newline RHS: variable id 8, ptr\_arith=1, offset 32(), type 0, name pi} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi = pi - 1} \\ \hline
            GIMPLE & \texttt{pi\_4 = pi\_3 + -4} \\ \hline
            Constraint & \texttt{LHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi,\newline RHS: variable id 8, ptr\_arith=1, offset 18446744073709551584(), type 0, name pi} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi++} \\ \hline
            GIMPLE & \texttt{pi\_5 = pi\_4 + 4} \\ \hline
            Constraint & \texttt{LHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi,\newline RHS: variable id 8, ptr\_arith=1, offset 32(), type 0, name pi} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi--} \\ \hline
            GIMPLE & \texttt{pi\_6 = pi\_5 + -4} \\ \hline
            Constraint & \texttt{LHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi,\newline RHS: variable id 8, ptr\_arith=1, offset 18446744073709551584(), type 0, name pi} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi = 0} \\ \hline
            GIMPLE & \texttt{pi\_7 = 0B} \\ \hline
            Constraint & \texttt{LHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi,\newline RHS: variable id 2, ptr\_arith=0, offset 0(), type 2, name null} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{pi = 17} \\ \hline
            GIMPLE & \texttt{pi\_8 = 17B} \\ \hline
            Constraint & \texttt{\textcolor{BrickRed}{No constraint generated}} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{f (pi)} \\ \hline
            GIMPLE & \texttt{f (pi\_8)} \\ \hline
            Constraint & \texttt{LHS: variable id 7, ptr\_arith=0, offset 0(), type 0, name pifp,\newline RHS: variable id 8, ptr\_arith=0, offset 0(), type 0, name pi} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{\ldots} \\ \hline
            GIMPLE & \texttt{D.2363\_2 = pifp\_1(D)} \\ \hline
            Constraint & \texttt{LHS: variable id 10, ptr\_arith=0, offset 0(), type 0, name D.2363,\newline RHS: variable id 7, ptr\_arith=0, offset 0(), type 0, name piFormal} \\
            \hline
            \hline
            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{return pifa} \\ \hline
            GIMPLE & \texttt{return D.2363\_2} \\ \hline
            Constraint & \texttt{Var id 10, name D.2363, offset 0} \\
            \hline
%            \hline
%            \textcolor{RoyalBlue}{\textbf{Source}} & \texttt{} \\ \hline
%            GIMPLE & \texttt{} \\ \hline
%            Constraint & \texttt{
%            } \\
%            \hline
        \end{longtable}
    \end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Change Patterns}\label{sec:change-patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\input{table1}
% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}

\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline

\rowcolor[HTML]{FFFC9E} 
Sr.No & Description                                                                                                   &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\ 

\hline
\rowcolor[HTML]{FFFC9E} 
1     & \begin{tabular}[c]{@{}l@{}}Mapping \\ old macros\\ to \\ new macros\end{tabular}                              & \begin{tabular}[c]{@{}l@{}}\#define VEC(A,B) vec\textless A\textgreater\\ \#define DEF\_VEC\_O(A)\\ \#define DEF\_VEC\_ALLOC\_O(A,B)\\ \#define DEF\_VEC\_P(A)\\ \#define DEF\_VEC\_ALLOC\_P(A,B)\\ \#define FOR\_EACH\_VEC\_ELT1(A,B,C,D) \\ FOR\_EACH\_VEC\_ELT(*B,C,D)\\ \#define FOR\_EACH\_LOOP1(li,loop,C) \\ FOR\_EACH\_LOOP(loop,C)\\ \#define VEC\_length(A,B) (*(B)).length()\\ \#define VEC\_free(A,B,C) (*C).release()\\ \#define VEC\_pop(A,B) (*B).pop()\\ \#define VEC\_index(A,B,C) ((*B){[}C{]})\\ \#define VEC\_empty(A,B) \\ ((*B).length() == 0)\\ \#define VEC\_qsort(A,B,C) \\ ((*B).qsort(C))\\ \#define VEC\_iterate(A,B,C,D) \\ (*B).iterate(C, \&(D))\\ \#define VEC\_safe\_push(A,B,C,D) \\ (*C).safe\_push(D)\\ \#define VEC\_last(A,B) \\ \&((*B){[}(*B).length()-1{]})\\ \#define VEC\_alloc(A,B,C) \\ new vec\textless A\textgreater ()\\ \#define VEC\_replace(T, V, I, V)\\  (*V).{[}(I){]} = (V)\end{tabular} \\ \hline

\rowcolor[HTML]{EFEFEF} 
2     & \begin{tabular}[c]{@{}l@{}}Change in \\ vector \\ allocation\end{tabular}                                     & \begin{tabular}[c]{@{}l@{}}VEC(constructor\_elt,gc) *v = \\ VEC\_alloc (constructor\_elt, gc, 100);\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \\ \hline
\rowcolor[HTML]{FFFC9E} 
      &                                                                                                               & \begin{tabular}[c]{@{}l@{}}vec\textless constructor\_elt\textgreater *v; \\ vec\_alloc (v, 100);\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \\ \hline
\rowcolor[HTML]{EFEFEF} 
3     & \begin{tabular}[c]{@{}l@{}}Change vector \\ length api\end{tabular}                                           & \begin{tabular}[c]{@{}l@{}}VEC(tree, gc) *params;\\ VEC\_length (tree, params);\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\ \hline
\rowcolor[HTML]{FFFC9E} 
      &                                                                                                               & \begin{tabular}[c]{@{}l@{}}vec\textless tree,va\_gc \textgreater *params;\\ params-\textgreater length ();\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \\ \hline

\end{tabular}
}
\end{table}

% \input{table2}
% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}

\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{EFEFEF} 
 4    & \begin{tabular}[c]{@{}l@{}}Iterating through \\ each basic block \\ of each \\ defined function.\end{tabular} & \begin{tabular}[c]{@{}l@{}}4.7\\ struct cgraph\_node * cnode = NULL;\\ for (cnode = cgraph\_nodes; cnode; \\ cnode = cnode-\textgreater next)\\ \{// skip nodes without a body, and \\ clone nodes,\\    if (!gimple\_has\_body\_p (cnode-\textgreater decl) || \\ cnode-\textgreater clone\_of)\\    continue;\\ \\    push\_cfun(\\ DECL\_STRUCT\_FUNCTION \\ (cnode-\textgreater decl));\\ \\    basic\_block current\_block;\\    FOR\_EACH\_BB (current\_block)\\    print\_parsed\_data (current\_block);\\ \}\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                               \\ \hline
\rowcolor[HTML]{FFFC9E} 
      &                                                                                                               & \begin{tabular}[c]{@{}l@{}}5.2\\ struct cgraph\_node * cnode = NULL;\\ FOR\_EACH\_DEFINED\_FUNCTION (cnode)\\ \{ \\ struct function *func; \\ if(!gimple\_has\_body\_p (cnode-\textgreater decl) ||\\ cnode-\textgreater clone\_of)\\ continue;\\ func=DECL\_STRUCT\_FUNCTION\\ (cnode-\textgreater decl);\\ push\_cfun(func);\\ basic\_block current\_block;\\ FOR\_EACH\_BB\_FN (current\_block,func)\\ print\_parsed\_data (current\_block);\\ \}\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \\ \hline

\rowcolor[HTML]{EFEFEF} 
5     & \begin{tabular}[c]{@{}l@{}}Change in \\ safe\_push api\end{tabular}                                           & \begin{tabular}[c]{@{}l@{}}4.7 vec\textless tree,va\_gc\textgreater *vec;\\ VEC\_safe\_push (tree\_gc\_vec, gc, \\ tree\_vector\_cache, vec);\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \\ \hline
\rowcolor[HTML]{FFFC9E} 
      &                                                                                                               &5.2 vec\_safe\_push (tree\_vector\_cache, vec);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \\ \hline
\rowcolor[HTML]{EFEFEF} 
6     & \begin{tabular}[c]{@{}l@{}}Change in \\ getName api\end{tabular}                                              & \begin{tabular}[c]{@{}l@{}}4.7 struct cgraph\_node *new\_node;\\ cgraph\_node\_name (new\_node)\end{tabular}                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                       \\ 
																																																																																																																																											
																																																																																																																																											                                                                                        
\rowcolor[HTML]{FFFC9E} 
      &                                                                                                               & \begin{tabular}[c]{@{}l@{}}5.2 struct cgraph\_node *new\_node; \\ new\_node-\textgreater name ();\end{tabular}
																																																																																																																																																																																																																															
																																																																																																																																																																																																																															\\ \hline                                                                                                                                                                                                                                                                                       
\end{tabular}
}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}\label{sec:future-work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}
    \item The plugin source has to be logically understood.
    \item A C constraint has to added. The C contraint, where a pointer is assigned an arbitrary integer (other than NULL) is not currently detected by the plugin.
    \item C++ constraints have to be included.
\end{enumerate}
